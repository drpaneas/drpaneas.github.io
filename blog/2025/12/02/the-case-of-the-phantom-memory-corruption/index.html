<!doctype html><html lang=en-us><head><title>The Case of the Phantom Memory Corruption // drpaneas</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Panos Georgiadis"><meta name=description content><link rel=stylesheet href=https://drpaneas.github.io/css/main.min.9babd84a07aaa904f1f9ad086b6855185c57a7814f72f68650eba6b68ad71834.css><meta name=twitter:card content="summary"><meta name=twitter:title content="The Case of the Phantom Memory Corruption"><meta name=twitter:description content="Or: How a Single Wrong Pointer Ruined My Week
I&rsquo;m building libgodc that is a Go runtime for the Sega Dreamcast. Yes, that Dreamcast. The one with the Hitachi SH-4 processor that Sega shipped (North America) in 9/9/1999. The one that ran Sonic Adventure and Crazy Taxi. I want it to run Go.
If you&rsquo;re wondering why anyone would do this: partly because it&rsquo;s fun, partly because constrained environments force you to truly understand what you&rsquo;re building."><meta property="og:title" content="The Case of the Phantom Memory Corruption"><meta property="og:description" content="Or: How a Single Wrong Pointer Ruined My Week
I&rsquo;m building libgodc that is a Go runtime for the Sega Dreamcast. Yes, that Dreamcast. The one with the Hitachi SH-4 processor that Sega shipped (North America) in 9/9/1999. The one that ran Sonic Adventure and Crazy Taxi. I want it to run Go.
If you&rsquo;re wondering why anyone would do this: partly because it&rsquo;s fun, partly because constrained environments force you to truly understand what you&rsquo;re building."><meta property="og:type" content="article"><meta property="og:url" content="https://drpaneas.github.io/blog/2025/12/02/the-case-of-the-phantom-memory-corruption/"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-12-02T02:46:35+01:00"><meta property="article:modified_time" content="2025-12-02T02:46:35+01:00"></head><body><header class=app-header><a href=https://drpaneas.github.io><img class=app-header-avatar src="https://github.com/drpaneas/drpaneas.github.io/blob/master/drpaneas.jpeg?raw=true" alt="Panos Georgiadis"></a><h1>drpaneas</h1><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a>
-
<a class=app-header-menu-item href=/about/>About</a></nav><p>Not all those who wander are lost</p><div class=app-header-social><a href=https://github.com/drpaneas target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/PanosGeorgiadis target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://www.linkedin.com/in/panosgeorgiadis/ target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin"><title>LinkedIn</title><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>The Case of the Phantom Memory Corruption</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Dec 2, 2025</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>22 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://drpaneas.github.io/tags/golang/>golang</a>
<a class=tag href=https://drpaneas.github.io/tags/dreamcast/>dreamcast</a>
<a class=tag href=https://drpaneas.github.io/tags/retro/>retro</a></div></div></header><div class=post-content><p><em>Or: How a Single Wrong Pointer Ruined My Week</em></p><hr><p>I&rsquo;m building <strong>libgodc</strong> that is a Go runtime for the Sega Dreamcast. Yes, that Dreamcast. The one with the Hitachi SH-4 processor that Sega shipped (North America) in 9/9/1999. The one that ran Sonic Adventure and Crazy Taxi. I want it to run Go.</p><p>If you&rsquo;re wondering why anyone would do this: partly because it&rsquo;s fun, partly because constrained environments force you to truly understand what you&rsquo;re building. The Dreamcast has 16MB of RAM and no operating system to speak of just <a href=http://gamedev.allusion.net/softprj/kos/>KallistiOS</a>, a homebrew development library. Every byte matters when you speak to metal. And unless you code in Rust, every abstraction has a cost. And <a href=https://x.com/falco_girgis/status/1991805987586543671>I made it</a>, with a really barebones runtime, but that&rsquo;s not what this story is all about. This story is about implementing goroutines &mldr; for Dreamcast!</p><p>Now, let&rsquo;s be honest about something upfront: <code>goroutines</code> on the Dreamcast are largely pointless from a practical standpoint. The SH-4 is a single-core CPU,there&rsquo;s no parallelism to exploit. You can&rsquo;t make things faster by spinning up more goroutines; they all take turns on the same processor. The &ldquo;concurrency&rdquo; you get is just cooperative multitasking with extra steps. If I wanted to ship a game, I&rsquo;d write straightforward C and be done in a weekend. But that&rsquo;s not the point. The point is proving it&rsquo;s <em>possible</em>,and in doing so, learning exactly how Go&rsquo;s runtime works at the deepest level.</p><blockquote><p>Sometimes the journey matters more than the destination, especially when the destination is about retro-gamedev!</p></blockquote><p>It started, as these things always do, with a test that should have been trivial. Actually, the test was embarrassingly simple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span> }()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span> }()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>    println(<span style=color:#e6db74>&#34;PASS&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Two goroutines send to a channel. Main receives twice. Print &ldquo;PASS&rdquo;. That&rsquo;s it.</p><p>The first receive worked. The second one? Kaboom. lol!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Unhandled exception: PC 8c01051e, code 1, evt 00e0
</span></span><span style=display:flex><span>R0-R7: <span style=color:#ae81ff>00000001</span> 8c080106 8c06d6bc 00000200...
</span></span></code></pre></div><p>A memory access violation. The program was trying to read from address <code>0x8c080106</code>, which &ldquo;spoiler alert&rdquo; contained nothing useful. On the Dreamcast, addresses starting with <code>0x8c</code> are in the main RAM region, but this particular address was in a no-man&rsquo;s land between initialized data and the heap.</p><p>I had no idea that this crash would consume the better part of two weeks (especially after midnight, when the little-ones are asleep).</p><hr><h2 id=a-quick-primer-stack-vs-heap-and-where-things-live>A Quick Primer: Stack vs Heap (and Where Things Live)</h2><p>Before we go further, let&rsquo;s make sure we&rsquo;re on the same page about where data lives in memory. If you&rsquo;ve never thought about this, here&rsquo;s a quick example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>example</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>42</span>              <span style=color:#75715e>// Lives on the STACK (local variable)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> new(<span style=color:#66d9ef>int</span>)        <span style=color:#75715e>// Lives on the HEAP (dynamically allocated)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>z</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>) <span style=color:#75715e>// Lives on the HEAP (runtime allocates it)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>x</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>z</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>The Stack</strong> is like a notepad that each function gets when it&rsquo;s called. Local variables (<code>x</code> in the example) go here. When the function returns, that notepad is thrown away. It&rsquo;s fast, automatic, and limited in size.</p><p><strong>The Heap</strong> is like a warehouse. When you need memory that outlives a function call,or when the compiler can&rsquo;t prove the data stays local,it goes here. Channels, slices, maps, and anything created with <code>new()</code> or <code>make()</code> typically live on the heap. The garbage collector&rsquo;s job is to clean up the warehouse when things are no longer needed.</p><h3 id=where-does-the-dreamcast-put-these>Where Does the Dreamcast Put These?</h3><p>The Dreamcast hardware doesn&rsquo;t have an operating system. It just exposes 16MB of RAM starting at address <code>0x8C000000</code>. That&rsquo;s it,raw memory, no stack, no heap, nothing organized.</p><p>So who creates the stack and heap? <strong>KallistiOS</strong> (the homebrew OS library) and <strong>libgodc</strong> (my Go runtime) do. In libgodc&rsquo;s source code, you can see exactly where these regions are defined:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// From runtime/dreamcast_support.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define DREAMCAST_RAM_BASE 0x8C000000
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define DREAMCAST_RAM_SIZE (16 * 1024 * 1024)  </span><span style=color:#75715e>// 16MB
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// From runtime/gc_semispace.h  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define GC_SEMISPACE_SIZE (2 * 1024 * 1024)    </span><span style=color:#75715e>// 2MB per space
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define GC_TOTAL_HEAP_SIZE (2 * GC_SEMISPACE_SIZE) </span><span style=color:#75715e>// 4MB total for GC
</span></span></span></code></pre></div><p>The memory layout looks roughly like this:</p><pre tabindex=0><code>Dreamcast RAM: 0x8C000000 - 0x8CFFFFFF (16MB)
┌─────────────────────────────────────────────────┐
│ Program code (.text)          ~0x8C010000       │ ← Your compiled Go code
│ Read-only data (.rodata)                        │ ← String literals, type descriptors
│ Initialized data (.data, .bss)                  │ ← Global variables
├─────────────────────────────────────────────────┤
│ GC Heap Space 0 (2MB)         ~0x8C080000       │ ← Go objects: channels, slices, etc.
│ GC Heap Space 1 (2MB)                           │ ← Used during garbage collection
├─────────────────────────────────────────────────┤
│ Goroutine stacks (8KB each)   ~0x8C480000       │ ← Each goroutine gets its own stack
│ KOS malloc arena                                │ ← General allocations
├─────────────────────────────────────────────────┤
│ Main thread stack             ~0x8CFFFFFF       │ ← KOS&#39;s main thread
└─────────────────────────────────────────────────┘
</code></pre><p>The GC heap is allocated by libgodc using KallistiOS&rsquo;s <code>memalign()</code> function,libgodc asks KOS for 4MB of memory, and KOS returns a pointer somewhere in the <code>0x8C08xxxx</code> range.</p><h3 id=whats-no-mans-land>What&rsquo;s &ldquo;No Man&rsquo;s Land&rdquo;?</h3><p>When I said the crash address <code>0x8c080106</code> was in &ldquo;no man&rsquo;s land,&rdquo; I meant it was in the gap between regions,after the initialized program data but before any actual heap objects were allocated. It&rsquo;s technically valid RAM, but nothing meaningful lives there. Reading from it returns garbage; writing to it corrupts nothing useful (until something <em>does</em> get allocated there).</p><p>Let me zoom into the GC heap region to show exactly where the corruption pointed:</p><pre tabindex=0><code>GC Heap Space 0 (starts at ~0x8C080000)
┌─────────────────────────────────────────────────────────────────────┐
│ 0x8C080000  ┌───────────────────────────────────────┐               │
│             │ Heap header / metadata                │               │
│ 0x8C080100  ├───────────────────────────────────────┤               │
│             │                                       │               │
│             │   ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░   │               │
│             │   ░░░░░ NO MAN&#39;S LAND ░░░░░░░░░░░░░   │  ← 0x8C080106 │
│             │   ░░░░░ (unallocated space) ░░░░░░░   │    points HERE│
│             │   ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░   │    (garbage!) │
│             │                                       │               │
│ 0x8C084000  ├───────────────────────────────────────┤               │
│             │ First real allocation (e.g. channel)  │               │
│ 0x8C084A50  │   ← The ACTUAL channel lives here     │  ← VALID ptr  │
│             │                                       │               │
│ 0x8C085000  ├───────────────────────────────────────┤               │
│             │ More Go objects...                    │               │
│             │                                       │               │
└─────────────┴───────────────────────────────────────┴───────────────┘
</code></pre><p>The corrupted pointer <code>0x8c080106</code> pointed to this wasteland because the memory corruption had overwritten a valid heap pointer (<code>0x8c084a50</code>, where the channel actually lived) with garbage bytes.</p><p>Now, with that context, let&rsquo;s look at Go&rsquo;s runtime internals.</p><hr><h2 id=a-brief-detour-how-gos-runtime-works>A Brief Detour: How Go&rsquo;s Runtime Works</h2><p>Before we dive into the debugging, let me explain some internals that most Go developers never need to think about.</p><p>When you write <code>go func() { ... }()</code>, the Go runtime creates a <strong>goroutine</strong>. Internally, the runtime represents each goroutine with a data structure called <code>G</code>. This isn&rsquo;t documented in the standard library. It lives in the <a href=https://github.com/golang/go/blob/master/src/runtime/runtime2.go>runtime source code</a>, and unless you&rsquo;re hacking on the runtime itself, you&rsquo;ll never see it.</p><p>The <code>G</code> struct contains everything the runtime needs to manage a goroutine: its stack boundaries, its current execution state, its panic/defer chains, and much more. Here&rsquo;s a simplified view:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>g</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stack</span>       <span style=color:#a6e22e>stack</span>   <span style=color:#75715e>// stack bounds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>_panic</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span> <span style=color:#75715e>// innermost panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>_defer</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span> <span style=color:#75715e>// innermost defer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>m</span>           <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>      <span style=color:#75715e>// current M (machine/OS thread)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sched</span>       <span style=color:#a6e22e>gobuf</span>   <span style=color:#75715e>// scheduling state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// ... dozens more fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>The runtime also has <code>M</code> (machine, representing an OS thread) and <code>P</code> (processor, representing a scheduling context). Together, G, M, and P form Go&rsquo;s famous <a href=https://leapcell.io/blog/unveiling-go-s-scheduler-secrets-the-g-m-p-model-in-action>GMP scheduler model</a>. For libgodc, I implement a simplified M:1 scheduler and all goroutines share a single OS thread and cooperatively yield to each other.</p><p>Channels are another runtime construct. When you call <code>make(chan bool, 2)</code>, the runtime allocates an <a href=https://github.com/golang/go/blob/master/src/runtime/chan.go><code>hchan</code> struct</a> that manages the buffer, the wait queues, and the synchronization. When a goroutine blocks on a channel operation, it gets added to a wait queue using a <code>sudog</code> (hort for &ldquo;pseudo-G&rdquo;) that is a structure that represents &ldquo;this goroutine is waiting for this specific operation.&rdquo; Here&rsquo;s how it looks like in memory:</p><pre tabindex=0><code>make(chan bool, 2) creates:

┌─────────────────────────────────────────────────────────────────────────┐
│                         hchan struct                                    │
├─────────────────────────────────────────────────────────────────────────┤
│  qcount: 0          │ Number of elements currently in buffer            │
│  dataqsiz: 2        │ Buffer capacity (we asked for 2)                  │
│  buf: ──────────────┼──► [  ] [  ]   ← Circular buffer for 2 bools      │
│  elemsize: 1        │ Size of each element (bool = 1 byte)              │
│  closed: false      │ Is the channel closed?                            │
│  sendq: ────────────┼──► (empty list of waiting senders)                │
│  recvq: ────────────┼──► (empty list of waiting receivers)              │
│  lock: ...          │ Mutex for thread safety                           │
└─────────────────────────────────────────────────────────────────────────┘
</code></pre><p>When a goroutine blocks on a channel operation, it gets added to a wait queue using a <code>sudog</code> (short for &ldquo;pseudo-G&rdquo;),a structure that represents &ldquo;this goroutine is waiting for this specific operation.&rdquo;</p><p>For example, when <code>main</code> calls <code>&lt;-done</code> but the channel is empty, here&rsquo;s what happens:</p><pre tabindex=0><code>BEFORE: main calls &lt;-done (channel empty, must wait)

┌─────────────────────────────────────────────────────────────────────────┐
│                         hchan struct                                    │
├─────────────────────────────────────────────────────────────────────────┤
│  qcount: 0                                                              │
│  buf: [  ] [  ]     ← Empty, nothing to receive                         │
│  sendq: ──────────► (empty)                                             │
│  recvq: ──────────► ┌─────────────────────────────────┐                 │
│                     │ sudog (main is waiting here)    │                 │
│                     │   g: ──► main&#39;s G struct        │                 │
│                     │   elem: ──► &amp;receivedValue      │ ← Where to put  │
│                     │   c: ──► this channel           │   the data      │
│                     └─────────────────────────────────┘                 │
└─────────────────────────────────────────────────────────────────────────┘

Main goroutine is now PARKED (sleeping), waiting for someone to send.

─────────────────────────────────────────────────────────────────────────────

AFTER: goroutine1 calls done &lt;- true

┌─────────────────────────────────────────────────────────────────────────┐
│  Sender finds main waiting in recvq!                                    │
│                                                                         │
│  Instead of putting &#39;true&#39; in the buffer, sender:                       │
│    1. Copies &#39;true&#39; directly to main&#39;s elem pointer                     │
│    2. Wakes up main (marks it runnable)                                 │
│    3. Removes sudog from recvq                                          │
│                                                                         │
│  recvq: ──────────► (empty again)                                       │
│  buf: [  ] [  ]     ← Buffer never used! Direct handoff.                │
└─────────────────────────────────────────────────────────────────────────┘

Main goroutine WAKES UP with the value already in its stack variable.
</code></pre><p>This direct handoff optimization is elegant,but it&rsquo;s also where our bug lurked. The sender writes directly to the receiver&rsquo;s stack. If the size is wrong, it overwrites adjacent memory.</p><p>With that context, let&rsquo;s get back to the crash.</p><hr><h2 id=down-the-rabbit-hole>Down the Rabbit Hole</h2><p>My first suspect was the context switching code. Goroutines on libgodc work through cooperative scheduling: when a goroutine blocks (say, waiting on a channel), it saves its CPU state and switches to another goroutine.</p><p>The SH-4 processor has registers r8 through r14 that are &ldquo;callee-saved&rdquo;, a.k.a. any function that uses them must restore their original values before returning. If my <code>swapcontext</code> assembly was corrupting any of them, chaos would ensue. A corrupted r14 (the frame pointer) would make the CPU look for local variables in the wrong place. A corrupted r8 might trash a value the caller was counting on.</p><p>I pulled up the disassembly. The <code>sh-elf-objdump</code> tool is part of the cross-compilation toolchain for SH-4, and the <code>-d</code> flag disassembles the binary:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sh-elf-objdump -d test_simple_exit.elf | grep -A <span style=color:#ae81ff>50</span> <span style=color:#e6db74>&#34;swapcontext&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>___go_swapcontext:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov.l</span>   <span style=color:#66d9ef>r8</span>, <span style=color:#960050;background-color:#1e0010>@</span>(<span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>r4</span>)    <span style=color:#75715e>; Save r8 to context
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mov.l</span>   <span style=color:#66d9ef>r9</span>, <span style=color:#960050;background-color:#1e0010>@</span>(<span style=color:#ae81ff>4</span>, <span style=color:#66d9ef>r4</span>)    <span style=color:#75715e>; Save r9
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mov.l</span>   <span style=color:#66d9ef>r10</span>, <span style=color:#960050;background-color:#1e0010>@</span>(<span style=color:#ae81ff>8</span>, <span style=color:#66d9ef>r4</span>)   <span style=color:#75715e>; Save r10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mov.l</span>   <span style=color:#66d9ef>r11</span>, <span style=color:#960050;background-color:#1e0010>@</span>(<span style=color:#ae81ff>12</span>, <span style=color:#66d9ef>r4</span>)  <span style=color:#75715e>; etc...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mov.l</span>   <span style=color:#66d9ef>r12</span>, <span style=color:#960050;background-color:#1e0010>@</span>(<span style=color:#ae81ff>16</span>, <span style=color:#66d9ef>r4</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov.l</span>   <span style=color:#66d9ef>r13</span>, <span style=color:#960050;background-color:#1e0010>@</span>(<span style=color:#ae81ff>20</span>, <span style=color:#66d9ef>r4</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov.l</span>   <span style=color:#66d9ef>r14</span>, <span style=color:#960050;background-color:#1e0010>@</span>(<span style=color:#ae81ff>24</span>, <span style=color:#66d9ef>r4</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>; ... restore from new context ...
</span></span></span></code></pre></div><p>The assembly looked fine. Registers saved, registers restored, nothing obviously wrong. But &ldquo;nothing obviously wrong&rdquo; is the most dangerous state in. It means the bug is hiding somewhere you haven&rsquo;t looked yet.</p><hr><h2 id=put-the-struct-in-order>Put the Struct in Order</h2><p>A friend suggested I check the <code>G</code> struct layout. Here&rsquo;s the thing about Go&rsquo;s runtime: the compiler generates code that accesses struct fields by <em>byte offset</em>, not by name. When the compiler emits code to read <code>gp.param</code>, it doesn&rsquo;t generate a symbolic reference to &ldquo;the param field.&rdquo; It generates &ldquo;load from address gp + 20&rdquo;. This is where 20 is the offset of <code>param</code> in the struct.</p><p>This means if you&rsquo;re implementing the runtime in C (as I am for libgodc), your struct layout must <em>exactly</em> match what the Go compiler expects. A mismatch means writes go to wrong fields, reads return garbage, and demons fly out of your nose.</p><p>I wrote a quick offset checker:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;param offset: %zu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>offsetof</span>(G, param));
</span></span></code></pre></div><p>The Go compiler expected <code>param</code> at offset 20. My struct had it at offset 240.</p><p><em>Two hundred and twenty bytes off.</em></p><p>When Go code wrote <code>gp.param = something</code>, it was actually scribbling over my <code>context.r9</code> field, in the right in the middle of saved register state. This was a real bug. But was it <em>the</em> bug?</p><p>I spent hours reordering the struct to match the expected layout. This meant carefully reading through <a href=https://github.com/pgeorgia/gccgo/blob/master/libgo/go/runtime/runtime2.go>gofrontend&rsquo;s runtime2.go</a> (gofrontend is GCC&rsquo;s Go implementation, which libgodc builds on) and matching every field:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> G {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> _PanicRecord <span style=color:#f92672>*</span>_panic;     <span style=color:#75715e>// Offset 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> _GccgoDefer <span style=color:#f92672>*</span>_defer;      <span style=color:#75715e>// Offset 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>m;                         <span style=color:#75715e>// Offset 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uintptr_t</span> syscallsp;             <span style=color:#75715e>// Offset 12
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uintptr_t</span> syscallpc;             <span style=color:#75715e>// Offset 16
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>param;                     <span style=color:#75715e>// Offset 20 - NOW CORRECT
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// ... 40+ more fields ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} G;
</span></span></code></pre></div><p>Rebuilt everything. Ran the test.</p><p>Same crash. Same corrupted address: <code>0x8c080106</code>.</p><p>The struct layout was a real bug! But it wasn&rsquo;t <em>this</em> bug. I had fixed something important, but the phantom corruption was still there.</p><hr><h2 id=the-crime>The Crime</h2><p>Time to get surgical. I needed to know exactly when the corruption happened.</p><p>The crash occurred when <code>main</code> tried to load the channel pointer from its stack. In Go, local variables live on the stack, and the channel variable <code>done</code> is no exception. Somewhere between &ldquo;main parks waiting for data&rdquo; and &ldquo;main wakes up,&rdquo; that pointer was getting trashed.</p><p>I added diagnostic prints to the channel receive code. The function <code>gopark</code> is what puts a goroutine to sleep and it saves the current state and switches to the scheduler:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Before parking
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>uint32_t</span> <span style=color:#f92672>*</span>chan_ptr_loc <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span><span style=color:#f92672>*</span>)(frame_pointer <span style=color:#f92672>+</span> <span style=color:#ae81ff>104</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;BEFORE: chan_ptr at %p = %08lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, chan_ptr_loc, <span style=color:#f92672>*</span>chan_ptr_loc);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gopark</span>(chanparkcommit, c, waitReasonChanReceive);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// After waking
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;AFTER: chan_ptr at %p = %08lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, chan_ptr_loc, <span style=color:#f92672>*</span>chan_ptr_loc);
</span></span></code></pre></div><p>The <code>frame_pointer + 104</code> calculation came from disassembling <code>main.main</code> and seeing where the compiler stored the <code>done</code> variable. This is tedious work: you look at the assembly, count the stack offsets, and figure out where each variable lives.</p><p>The output was damning:</p><pre tabindex=0><code>BEFORE: chan_ptr at 0x8c488728 = 8c084a50
AFTER:  chan_ptr at 0x8c488728 = 8c080106
</code></pre><p>The pointer was fine when main went to sleep. It was corrupted when main woke up. Something happened <em>while main was parked</em> and the only things running during that time were the sender goroutines.</p><p>This was a crucial realization. The corruption wasn&rsquo;t happening in main&rsquo;s code. It was happening in <em>someone else&rsquo;s</em> code, stomping on main&rsquo;s stack from the outside.</p><hr><h2 id=following-the-money>Following the Money</h2><p>In channel operations, when a sender finds a waiting receiver, it copies data directly to the receiver&rsquo;s stack. This is an optimization,instead of putting the data in the channel buffer and having the receiver copy it out, the sender writes straight to where the receiver wants the data.</p><p>The receiver provides a pointer (<code>sg->elem</code>) saying &ldquo;put the data here.&rdquo; The sender does <code>memcpy(sg->elem, &amp;value, size)</code>.</p><p>Here&rsquo;s how the direct handoff works:</p><pre tabindex=0><code>SENDER (goroutine1)                         RECEIVER (main, parked)
                                            
   done &lt;- true                              &lt;-done (waiting)
       │                                           │
       ▼                                           ▼
┌──────────────────┐                    ┌──────────────────────────────┐
│ value = true     │                    │ Main&#39;s Stack                 │
│ (1 byte: 0x01)   │                    │                              │
└────────┬─────────┘                    │  0x8c488766: receivedValue   │◄─┐
         │                              │  0x8c488768: done (chan ptr) │  │
         │   memcpy(sg-&gt;elem,           │  0x8c48876C: other locals... │  │
         │          &amp;value,             └──────────────────────────────┘  │
         │          elemsize)                                             │
         │                                                                │
         └──────────── sg-&gt;elem points here ──────────────────────────────┘
                       &#34;Copy the value directly to receiver&#39;s stack&#34;
</code></pre><p>I added more instrumentation to the send path:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;sg-&gt;elem = %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, sg<span style=color:#f92672>-&gt;</span>elem);
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;channel elemsize = %u</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, c<span style=color:#f92672>-&gt;</span>elemsize);
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;memcpy %u bytes to %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, c<span style=color:#f92672>-&gt;</span>elemsize, sg<span style=color:#f92672>-&gt;</span>elem);
</span></span></code></pre></div><p>And there it was:</p><pre tabindex=0><code>Main&#39;s chan_ptr at 0x8c488768
sg-&gt;elem = 0x8c488766
memcpy 4 bytes to 0x8c488766
</code></pre><p>Do you see it?</p><p>The receiver&rsquo;s element pointer was at <code>0x8c488766</code>. The channel pointer was at <code>0x8c488768</code>. That&rsquo;s a difference of <em>two bytes</em>. The memcpy was writing <em>four</em> bytes.</p><p>Here&rsquo;s what SHOULD have happened (1-byte write for bool):</p><pre tabindex=0><code>Main&#39;s Stack (addresses grow DOWN)
                                                    
Address      Before          After memcpy(1 byte)   
─────────────────────────────────────────────────────
0x8c488766   [  ??  ]        [  01  ]  ← bool &#39;true&#39; written here ✓
0x8c488767   [  ??  ]        [  ??  ]  ← untouched
0x8c488768   [  50  ]  ─┐    [  50  ]  ─┐
0x8c488769   [  4a  ]   │    [  4a  ]   │  Channel pointer
0x8c48876a   [  08  ]   ├─►  [  08  ]   ├─►  0x8c084a50 (VALID!)
0x8c48876b   [  8c  ]  ─┘    [  8c  ]  ─┘
</code></pre><p>Here&rsquo;s what ACTUALLY happened (4-byte write, WRONG!):</p><pre tabindex=0><code>Main&#39;s Stack (addresses grow DOWN)
                                                    
Address      Before          After memcpy(4 bytes)   
─────────────────────────────────────────────────────
0x8c488766   [  ??  ]        [  01  ]  ← bool &#39;true&#39;
0x8c488767   [  ??  ]        [  06  ]  ← OVERFLOW! garbage byte
0x8c488768   [  50  ]  ─┐    [  01  ]  ← CORRUPTED! was part of chan ptr
0x8c488769   [  4a  ]   │    [  08  ]  ← CORRUPTED! 
0x8c48876a   [  08  ]   ├─►  [  08  ]   ├─►  0x8c080106 (GARBAGE!)
0x8c48876b   [  8c  ]  ─┘    [  8c  ]  ─┘
                        
             VALID               CORRUPTED
          0x8c084a50           0x8c080106
</code></pre><p>The 4-byte memcpy steamrolled right over the channel pointer!</p><p>Mystery solved,sort of. But why four bytes? The channel held <code>bool</code> values. A bool is one byte</p><hr><h2 id=gate-4-παοκ>GATE-4 ΠΑΟΚ</h2><p>I traced back to channel creation. When you call <code>make(chan bool, 2)</code>, the runtime calls an internal function <code>makechan</code> that allocates the channel structure. One of its jobs is to determine the element size:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>hchan <span style=color:#f92672>*</span><span style=color:#a6e22e>makechan</span>(<span style=color:#66d9ef>struct</span> __go_type_descriptor <span style=color:#f92672>*</span>elemtype, <span style=color:#66d9ef>int64_t</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> elemsize <span style=color:#f92672>=</span> elemtype<span style=color:#f92672>-&gt;</span>__size;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;elemsize = %zu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, elemsize);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Output:</p><pre tabindex=0><code>elemsize = 4
</code></pre><p>Four bytes. But bool is one byte. What was going on?</p><p>Here&rsquo;s where I need to explain something about Go&rsquo;s type system at the runtime level. Every type in Go has a <strong>type descriptor</strong>, a data structure that describes the type&rsquo;s size, its alignment, how to compare values of that type, how the garbage collector should scan it, and more. The compiler generates these descriptors and embeds them in the binary.</p><p>When you compile a Go program, you can see these type descriptors in the symbol table. The <code>nm</code> tool lists all symbols in a binary:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sh-elf-nm test_simple_exit.elf | grep <span style=color:#e6db74>&#34;type\.\.&#34;</span>
</span></span></code></pre></div><pre tabindex=0><code>8c052198 V _type..bool
8c0521bc V _type..chan_bbool
8c0521e4 V _type..func()
</code></pre><p>Each <code>_type..XXX</code> symbol is a type descriptor. The address <code>0x8c0521bc</code> is the descriptor for <code>chan bool</code>.</p><p>I had printed that the type descriptor passed to <code>makechan</code> was at address <code>0x8c0521bc</code>. Looking it up:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sh-elf-nm test_simple_exit.elf | grep 8c0521bc
</span></span></code></pre></div><pre tabindex=0><code>8c0521bc V _type..chan_bbool
</code></pre><p>That&rsquo;s <code>chan bool</code>, in which the <em>channel</em> type, not the <em>element</em> type!</p><hr><h2 id=understanding-the-root-cause>Understanding the Root Cause</h2><p>Here&rsquo;s what I had missed. The Go compiler doesn&rsquo;t pass the element type to <code>makechan</code>. It passes the <em>channel</em> type. This makes sense if you think about it,the runtime might need to know things about the channel itself (like its direction: send-only, receive-only, or bidirectional).</p><p>But the channel type descriptor contains a pointer to the element type. Let me visualize the type descriptor hierarchy:</p><pre tabindex=0><code>When you write: make(chan bool, 2)

The compiler generates TWO type descriptors in the binary:

┌─────────────────────────────────────────────────────────────────────────────┐
│  _type..bool (at 0x8c052198)                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  __go_type_descriptor                                               │    │
│  │    __size: 1          ← bool is 1 byte                              │    │
│  │    __ptrdata: 0                                                     │    │
│  │    __hash: 0x...                                                    │    │
│  │    __code: kindBool                                                 │    │
│  │    ...                                                              │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  _type..chan_bbool (at 0x8c0521bc)                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  __go_chan_type                                                     │    │
│  │    __common: (embedded __go_type_descriptor)                        │    │
│  │      __size: 4        ← size of the chan_type struct itself!        │    │
│  │      __code: kindChan                                               │    │
│  │      ...                                                            │    │
│  │    __element_type: ───────────────────────────────────────────────────►  │
│  │    __dir: bothDir     (send and receive)                            │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
                                                                          │
                                              Points to _type..bool ◄─────┘
</code></pre><p>The Go compiler passes <code>_type..chan_bbool</code> (the channel type) to <code>makechan</code>, NOT <code>_type..bool</code> (the element type). The channel type <em>contains</em> a pointer to the element type.</p><p>Here&rsquo;s the structure in C:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// A plain type descriptor (for simple types like bool, int, etc.)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> __go_type_descriptor {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uintptr_t</span> __size;        <span style=color:#75715e>// Size of values of this type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uintptr_t</span> __ptrdata;     <span style=color:#75715e>// Size of memory prefix holding pointers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint32_t</span> __hash;         <span style=color:#75715e>// Hash of the type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// ... more fields ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// A channel type descriptor (extends the base descriptor)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> __go_chan_type {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> __go_type_descriptor __common;          <span style=color:#75715e>// Base type info (36 bytes)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> __go_type_descriptor <span style=color:#f92672>*</span>__element_type;   <span style=color:#75715e>// Pointer to element&#39;s type!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uintptr_t</span> __dir;                               <span style=color:#75715e>// Channel direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>So when you have a <code>chan bool</code>, the type descriptor passed to <code>makechan</code> is a <code>__go_chan_type</code>. Its <code>__common.__size</code> field is NOT the element size,it&rsquo;s the size of the channel type descriptor struct itself (which happens to be 4 bytes). The <em>actual element size</em> is hidden one pointer away, in <code>__element_type->__size</code>.</p><p>My original code was doing this:</p><pre tabindex=0><code>WRONG: Reading __size from the channel type directly

  makechan receives: chantype ──► _type..chan_bbool
                                        │
                                        ▼
                              ┌─────────────────────┐
                              │ __common.__size: 4  │ ◄── I read THIS
                              │ __element_type: ─────────► _type..bool
                              │ __dir: bothDir      │            │
                              └─────────────────────┘            ▼
                                                        ┌───────────────┐
                                                        │ __size: 1     │
                                                        └───────────────┘
                                                          (never reached!)

  Result: elemsize = 4  ← WRONG! This is the chan_type struct size!
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// WRONG: This reads the channel type&#39;s size, not the element&#39;s size!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>size_t</span> elemsize <span style=color:#f92672>=</span> chantype<span style=color:#f92672>-&gt;</span>__size;  <span style=color:#75715e>// Returns 4 (size of chan type descriptor)
</span></span></span></code></pre></div><p>It should have been doing this:</p><pre tabindex=0><code>CORRECT: Following the pointer to get the element type&#39;s size

  makechan receives: chantype ──► _type..chan_bbool
                                        │
                                        ▼
                              ┌─────────────────────┐
                              │ __common.__size: 4  │   (ignored)
                              │ __element_type: ─────────► _type..bool
                              │ __dir: bothDir      │            │
                              └─────────────────────┘            ▼
                                                        ┌───────────────┐
                                                        │ __size: 1     │ ◄── Read THIS
                                                        └───────────────┘

  Result: elemsize = 1  ← CORRECT! This is the actual bool size!
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// CORRECT: Cast to chan_type, then get the element type&#39;s size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> __go_chan_type <span style=color:#f92672>*</span>ct <span style=color:#f92672>=</span> (<span style=color:#66d9ef>struct</span> __go_chan_type <span style=color:#f92672>*</span>)chantype;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> __go_type_descriptor <span style=color:#f92672>*</span>elemtype <span style=color:#f92672>=</span> ct<span style=color:#f92672>-&gt;</span>__element_type;
</span></span><span style=display:flex><span><span style=color:#66d9ef>size_t</span> elemsize <span style=color:#f92672>=</span> elemtype<span style=color:#f92672>-&gt;</span>__size;  <span style=color:#75715e>// Returns 1 (size of bool)
</span></span></span></code></pre></div><p>The fix was three lines, but understanding <em>why</em> those three lines were needed took days of investigation</p><hr><h2 id=the-corruption-pattern-explained>The Corruption Pattern Explained</h2><p>With the root cause understood, the corrupted value <code>0x8c080106</code> suddenly made sense. Let me walk through exactly how the bytes got mangled.</p><p>When the sender executes <code>done &lt;- true</code>, it has a local variable containing the value <code>true</code>:</p><pre tabindex=0><code>Sender&#39;s stack (source of memcpy):

Address       Value      Meaning
────────────────────────────────────────────
0x8c487f00    [  01  ]   ← bool &#39;true&#39; (this is what we want to send)
0x8c487f01    [  06  ]   ← garbage (uninitialized stack memory)
0x8c487f02    [  08  ]   ← more garbage
0x8c487f03    [  8c  ]   ← more garbage
              ▲
              │
              └── memcpy starts here, copies 4 bytes (WRONG! should be 1)
</code></pre><p>The receiver (<code>main</code>) has its local variables laid out on the stack:</p><pre tabindex=0><code>Main&#39;s stack BEFORE the memcpy:

Address       Value      Variable
────────────────────────────────────────────
0x8c488766    [  ??  ]   ← receivedValue (where bool should go)
0x8c488767    [  ??  ]   ← (padding/alignment)
0x8c488768    [  50  ]  ─┐
0x8c488769    [  4a  ]   │  &#39;done&#39; channel pointer
0x8c48876a    [  08  ]   │  = 0x8c084a50 (little-endian)
0x8c48876b    [  8c  ]  ─┘  Points to valid hchan on heap
</code></pre><p>The sender does <code>memcpy(sg->elem, &amp;value, 4)</code> , writing 4 bytes instead of 1:</p><pre tabindex=0><code>memcpy copies 4 bytes from sender to receiver:

Source:           Destination:
[01 06 08 8c] ──► [?? ?? 50 4a]
                       ▲
                       │
                  Overwrites into channel pointer!

Main&#39;s stack AFTER the memcpy:

Address       Value      What happened
────────────────────────────────────────────
0x8c488766    [  01  ]   ← bool &#39;true&#39; ✓ (correct)
0x8c488767    [  06  ]   ← GARBAGE from sender&#39;s stack!
0x8c488768    [  08  ]  ─┐ CORRUPTED! Was [50]
0x8c488769    [  8c  ]   │ CORRUPTED! Was [4a]
0x8c48876a    [  08  ]   │ (unchanged, lucky coincidence)
0x8c48876b    [  8c  ]  ─┘ (unchanged)
</code></pre><p>When <code>main</code> wakes up and tries to use the channel again, it reads the pointer:</p><pre tabindex=0><code>Reading &#39;done&#39; as little-endian 32-bit pointer:

Address       Byte
────────────────────
0x8c488768    [08]  ← least significant byte
0x8c488769    [8c]
0x8c48876a    [08]
0x8c48876b    [8c]  ← most significant byte

Reassembled: 0x8c080106  ← GARBAGE POINTER!

Compare to original: 0x8c084a50  ← Valid channel

                     0x8c08 4a50
                          ↓
                     0x8c08 0106  ← Middle bytes corrupted!
</code></pre><h3 id=the-fingerprint>The Fingerprint</h3><p>Notice something interesting? The corrupted value <code>0x8c080106</code> contains <code>01</code> , that&rsquo;s the boolean <code>true</code> we were trying to send! The corruption left a fingerprint:</p><pre tabindex=0><code>Corrupted pointer: 0x8c080106
                        ││
                        │└── 06 = garbage from sender&#39;s stack
                        └─── 01 = the boolean &#39;true&#39; value!
</code></pre><p>If I had recognized this pattern earlier,&ldquo;why does the corrupted pointer contain <code>01</code>?",I might have connected it to the channel send much sooner.</p><hr><h2 id=could-i-have-found-this-faster>Could I Have Found This Faster?</h2><p>Absolutely. Looking back, there were several points where I could have short-circuited the investigation:</p><p><strong>1. I should have checked the element size immediately.</strong></p><p>When the crash first happened, I could have added a simple print to <code>makechan</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Creating channel: elemsize=%zu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, elemsize);
</span></span></code></pre></div><p>Seeing &ldquo;elemsize=4&rdquo; for a <code>chan bool</code> would have been an immediate red flag. Instead, I spent days chasing register corruption theories.</p><p><strong>2. I should have analyzed the corrupted value sooner.</strong></p><p>The value <code>0x8c080106</code> wasn&rsquo;t random. It had structure:</p><ul><li>The upper bytes <code>08 8c</code> matched the heap region prefix</li><li>The <code>01</code> byte screamed &ldquo;boolean true&rdquo;</li></ul><p>If I had stared at that value and asked &ldquo;where could <code>01</code> come from?&rdquo;, I might have connected it to the channel send much earlier.</p><p><strong>3. I should have added memory guards.</strong></p><p>A simple technique: when allocating the receive buffer, pad it with known sentinel values and check if they get overwritten:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Allocate extra space with sentinels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>16</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0xDE</span>, <span style=color:#ae81ff>0xAD</span>, <span style=color:#ae81ff>0xBE</span>, <span style=color:#ae81ff>0xEF</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0xDE</span>, <span style=color:#ae81ff>0xAD</span>, <span style=color:#ae81ff>0xBE</span>, <span style=color:#ae81ff>0xEF</span>, ...};
</span></span><span style=display:flex><span><span style=color:#75715e>// The actual receive goes into buffer[4]
</span></span></span><span style=display:flex><span><span style=color:#75715e>// After receive, check if buffer[0..3] or buffer[5..] changed
</span></span></span></code></pre></div><p>This would have immediately shown that the write was overflowing.</p><p><strong>4. I got distracted by the struct layout issue.</strong></p><p>The G struct layout mismatch was a real bug, and fixing it was the right thing to do. But I spent too long on it, convinced it must be the cause of this specific crash. When the crash persisted after the fix, I should have immediately pivoted to other theories instead of double-checking the struct layout for the third time.</p><hr><h2 id=the-lesson>The Lesson</h2><p>This bug took about four days to find. That might sound like a lot for what turned out to be a simple type confusion. But here&rsquo;s the thing: debugging is rarely a straight line.</p><p>I went down the register corruption path. Dead end, but I learned my context switching was correct.</p><p>I went down the struct layout path. Found and fixed a real bug, but not <em>this</em> bug.</p><p>I went down the stack corruption path. Finally found the culprit.</p><p>Each &ldquo;wrong&rdquo; path wasn&rsquo;t wasted time. It was eliminating possibilities and building understanding. The struct layout investigation taught me exactly how gofrontend lays out its data structures. The register corruption investigation confirmed my assembly was sound. By the time I found the real bug, I understood the system much more deeply than when I started.</p><p>That&rsquo;s how you build expertise. Not by reading documentation (though that helps), but by breaking things and figuring out why they broke.</p><hr><h2 id=epilogue>Epilogue</h2><p>The Dreamcast is a ~30-year-old console. Getting Go to run on it means understanding both the high-level abstractions and the low-level reality of how compilers generate code. The Go language presents a clean model: goroutines, channels, garbage collection. But underneath, there&rsquo;s assembly code shuffling registers, type descriptors encoding metadata, and memory being copied byte by byte.</p><p>Sometimes a bug that looks like black magic: registers corrupted, pointers changing spontaneously, has a perfectly mundane explanation. A type cast that should have been there. A field that should have been dereferenced. Three lines of code.</p><p>You just have to find it.</p><hr><p><em>The code for libgodc (will soon be available) at <a href=https://github.com/drpaneas/libgodc>github.com/drpaneas/libgodc</a>. If you&rsquo;re interested in Go internals, I recommend reading the <a href=https://github.com/golang/go/tree/master/src/runtime>runtime source code</a>. It&rsquo;s surprisingly approachable, and there&rsquo;s no better way to understand what your programs are actually doing.</em></p></div><div class=post-footer></div></article></main></body></html>