<!doctype html><html lang=en-us><head><title>The Case of the Phantom Memory Corruption // drpaneas</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Panos Georgiadis"><meta name=description content><link rel=stylesheet href=https://drpaneas.github.io/css/main.min.9babd84a07aaa904f1f9ad086b6855185c57a7814f72f68650eba6b68ad71834.css><meta name=twitter:card content="summary"><meta name=twitter:title content="The Case of the Phantom Memory Corruption"><meta name=twitter:description content="Or: How a Single Wrong Pointer Ruined My Week
It started, as these things always do, with a test that should have been trivial.
I&rsquo;m building libgodc that is a Go runtime for the Sega Dreamcast. Yes, that Dreamcast. The one with the Hitachi SH-4 processor that Sega shipped in 1998. The one that ran Sonic Adventure and Soul Calibur. I want it to run Go.
If you&rsquo;re wondering why anyone would do this: partly because it&rsquo;s fun, partly because constrained environments force you to truly understand what you&rsquo;re building."><meta property="og:title" content="The Case of the Phantom Memory Corruption"><meta property="og:description" content="Or: How a Single Wrong Pointer Ruined My Week
It started, as these things always do, with a test that should have been trivial.
I&rsquo;m building libgodc that is a Go runtime for the Sega Dreamcast. Yes, that Dreamcast. The one with the Hitachi SH-4 processor that Sega shipped in 1998. The one that ran Sonic Adventure and Soul Calibur. I want it to run Go.
If you&rsquo;re wondering why anyone would do this: partly because it&rsquo;s fun, partly because constrained environments force you to truly understand what you&rsquo;re building."><meta property="og:type" content="article"><meta property="og:url" content="https://drpaneas.github.io/blog/2025/12/02/the-case-of-the-phantom-memory-corruption/"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-12-02T02:46:35+01:00"><meta property="article:modified_time" content="2025-12-02T02:46:35+01:00"></head><body><header class=app-header><a href=https://drpaneas.github.io><img class=app-header-avatar src="https://github.com/drpaneas/drpaneas.github.io/blob/master/drpaneas.jpeg?raw=true" alt="Panos Georgiadis"></a><h1>drpaneas</h1><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a>
-
<a class=app-header-menu-item href=/about/>About</a></nav><p>Not all those who wander are lost</p><div class=app-header-social><a href=https://github.com/drpaneas target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/PanosGeorgiadis target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://www.linkedin.com/in/panosgeorgiadis/ target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin"><title>LinkedIn</title><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>The Case of the Phantom Memory Corruption</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Dec 2, 2025</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>13 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://drpaneas.github.io/tags/golang/>golang</a>
<a class=tag href=https://drpaneas.github.io/tags/dreamcast/>dreamcast</a>
<a class=tag href=https://drpaneas.github.io/tags/retro/>retro</a></div></div></header><div class=post-content><p><em>Or: How a Single Wrong Pointer Ruined My Week</em></p><hr><p>It started, as these things always do, with a test that should have been trivial.</p><p>I&rsquo;m building <strong>libgodc</strong> that is a Go runtime for the Sega Dreamcast. Yes, that Dreamcast. The one with the Hitachi SH-4 processor that Sega shipped in 1998. The one that ran Sonic Adventure and Soul Calibur. I want it to run Go.</p><p>If you&rsquo;re wondering why anyone would do this: partly because it&rsquo;s fun, partly because constrained environments force you to truly understand what you&rsquo;re building. The Dreamcast has 16MB of RAM and no operating system to speak of just <a href=http://gamedev.allusion.net/softprj/kos/>KallistiOS</a>, a homebrew development library. Every byte matters. Every abstraction has a cost.</p><p>The test was embarrassingly simple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span> }()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span> }()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>    println(<span style=color:#e6db74>&#34;PASS&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Two goroutines send to a channel. Main receives twice. Print &ldquo;PASS&rdquo;. That&rsquo;s it.</p><p>The first receive worked. The second one? Kaboom.</p><pre tabindex=0><code>Unhandled exception: PC 8c01051e, code 1, evt 00e0
R0-R7: 00000001 8c080106 8c06d6bc 00000200...
</code></pre><p>A memory access violation. The program was trying to read from address <code>0x8c080106</code>, which &ldquo;spoiler alert&rdquo; contained nothing useful. On the Dreamcast, addresses starting with <code>0x8c</code> are in the main RAM region, but this particular address was in a no-man&rsquo;s land between initialized data and the heap.</p><p>I had no idea that this crash would consume the better part of a week.</p><hr><h2 id=a-brief-detour-how-gos-runtime-works>A Brief Detour: How Go&rsquo;s Runtime Works</h2><p>Before we dive into the debugging, let me explain some internals that most Go developers never need to think about.</p><p>When you write <code>go func() { ... }()</code>, the Go runtime creates a <strong>goroutine</strong>. Internally, the runtime represents each goroutine with a data structure called <code>G</code>. This isn&rsquo;t documented in the standard library. It lives in the <a href=https://github.com/golang/go/blob/master/src/runtime/runtime2.go>runtime source code</a>, and unless you&rsquo;re hacking on the runtime itself, you&rsquo;ll never see it.</p><p>The <code>G</code> struct contains everything the runtime needs to manage a goroutine: its stack boundaries, its current execution state, its panic/defer chains, and much more. Here&rsquo;s a simplified view:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>g</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stack</span>       <span style=color:#a6e22e>stack</span>   <span style=color:#75715e>// stack bounds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>_panic</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span> <span style=color:#75715e>// innermost panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>_defer</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span> <span style=color:#75715e>// innermost defer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>m</span>           <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>      <span style=color:#75715e>// current M (machine/OS thread)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sched</span>       <span style=color:#a6e22e>gobuf</span>   <span style=color:#75715e>// scheduling state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// ... dozens more fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>The runtime also has <code>M</code> (machine, representing an OS thread) and <code>P</code> (processor, representing a scheduling context). Together, G, M, and P form Go&rsquo;s famous <a href=https://go.dev/src/runtime/proc.go>GMP scheduler model</a>. For libgodc, I implement a simplified M:1 scheduler and all goroutines share a single OS thread and cooperatively yield to each other.</p><p>Channels are another runtime construct. When you call <code>make(chan bool, 2)</code>, the runtime allocates an <a href=https://github.com/golang/go/blob/master/src/runtime/chan.go><code>hchan</code> struct</a> that manages the buffer, the wait queues, and the synchronization. When a goroutine blocks on a channel operation, it gets added to a wait queue using a <code>sudog</code> (short for &ldquo;pseudo-G&rdquo;) that is a structure that represents &ldquo;this goroutine is waiting for this specific operation.&rdquo;</p><p>With that context, let&rsquo;s get back to the crash.</p><hr><h2 id=down-the-rabbit-hole>Down the Rabbit Hole</h2><p>My first suspect was the context switching code. Goroutines on libgodc work through cooperative scheduling: when a goroutine blocks (say, waiting on a channel), it saves its CPU state and switches to another goroutine.</p><p>The SH-4 processor has registers r8 through r14 that are &ldquo;callee-saved&rdquo;, a.k.a. any function that uses them must restore their original values before returning. If my <code>swapcontext</code> assembly was corrupting any of them, chaos would ensue. A corrupted r14 (the frame pointer) would make the CPU look for local variables in the wrong place. A corrupted r8 might trash a value the caller was counting on.</p><p>I pulled up the disassembly. The <code>sh-elf-objdump</code> tool is part of the cross-compilation toolchain for SH-4, and the <code>-d</code> flag disassembles the binary:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sh-elf-objdump -d test_simple_exit.elf | grep -A <span style=color:#ae81ff>50</span> <span style=color:#e6db74>&#34;swapcontext&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>___go_swapcontext:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov.l</span>   <span style=color:#66d9ef>r8</span>, <span style=color:#960050;background-color:#1e0010>@</span>(<span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>r4</span>)    <span style=color:#75715e>; Save r8 to context
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mov.l</span>   <span style=color:#66d9ef>r9</span>, <span style=color:#960050;background-color:#1e0010>@</span>(<span style=color:#ae81ff>4</span>, <span style=color:#66d9ef>r4</span>)    <span style=color:#75715e>; Save r9
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mov.l</span>   <span style=color:#66d9ef>r10</span>, <span style=color:#960050;background-color:#1e0010>@</span>(<span style=color:#ae81ff>8</span>, <span style=color:#66d9ef>r4</span>)   <span style=color:#75715e>; Save r10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mov.l</span>   <span style=color:#66d9ef>r11</span>, <span style=color:#960050;background-color:#1e0010>@</span>(<span style=color:#ae81ff>12</span>, <span style=color:#66d9ef>r4</span>)  <span style=color:#75715e>; etc...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mov.l</span>   <span style=color:#66d9ef>r12</span>, <span style=color:#960050;background-color:#1e0010>@</span>(<span style=color:#ae81ff>16</span>, <span style=color:#66d9ef>r4</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov.l</span>   <span style=color:#66d9ef>r13</span>, <span style=color:#960050;background-color:#1e0010>@</span>(<span style=color:#ae81ff>20</span>, <span style=color:#66d9ef>r4</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov.l</span>   <span style=color:#66d9ef>r14</span>, <span style=color:#960050;background-color:#1e0010>@</span>(<span style=color:#ae81ff>24</span>, <span style=color:#66d9ef>r4</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>; ... restore from new context ...
</span></span></span></code></pre></div><p>The assembly looked fine. Registers saved, registers restored, nothing obviously wrong. But &ldquo;nothing obviously wrong&rdquo; is the most dangerous state in. It means the bug is hiding somewhere you haven&rsquo;t looked yet.</p><hr><h2 id=the-struct-layout-massacre>The Struct Layout Massacre</h2><p>A friend suggested I check the <code>G</code> struct layout. Here&rsquo;s the thing about Go&rsquo;s runtime: the compiler generates code that accesses struct fields by <em>byte offset</em>, not by name. When the compiler emits code to read <code>gp.param</code>, it doesn&rsquo;t generate a symbolic reference to &ldquo;the param field.&rdquo; It generates &ldquo;load from address gp + 20&rdquo;. This is where 20 is the offset of <code>param</code> in the struct.</p><p>This means if you&rsquo;re implementing the runtime in C (as I am for libgodc), your struct layout must <em>exactly</em> match what the Go compiler expects. A mismatch means writes go to wrong fields, reads return garbage, and demons fly out of your nose.</p><p>I wrote a quick offset checker:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;param offset: %zu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>offsetof</span>(G, param));
</span></span></code></pre></div><p>The Go compiler expected <code>param</code> at offset 20. My struct had it at offset 240.</p><p><em>Two hundred and twenty bytes off.</em></p><p>When Go code wrote <code>gp.param = something</code>, it was actually scribbling over my <code>context.r9</code> field, in the right in the middle of saved register state. This was a real bug. But was it <em>the</em> bug?</p><p>I spent hours reordering the struct to match the expected layout. This meant carefully reading through <a href=https://github.com/pgeorgia/gccgo/blob/master/libgo/go/runtime/runtime2.go>gofrontend&rsquo;s runtime2.go</a> (gofrontend is GCC&rsquo;s Go implementation, which libgodc builds on) and matching every field:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> G {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> _PanicRecord <span style=color:#f92672>*</span>_panic;     <span style=color:#75715e>// Offset 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> _GccgoDefer <span style=color:#f92672>*</span>_defer;      <span style=color:#75715e>// Offset 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>m;                         <span style=color:#75715e>// Offset 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uintptr_t</span> syscallsp;             <span style=color:#75715e>// Offset 12
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uintptr_t</span> syscallpc;             <span style=color:#75715e>// Offset 16
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>param;                     <span style=color:#75715e>// Offset 20 - NOW CORRECT
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// ... 40+ more fields ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} G;
</span></span></code></pre></div><p>Rebuilt everything. Ran the test.</p><p>Same crash. Same corrupted address: <code>0x8c080106</code>.</p><p>The struct layout was a real bug! But it wasn&rsquo;t <em>this</em> bug. I had fixed something important, but the phantom corruption was still there.</p><hr><h2 id=instrumenting-the-crime-scene>Instrumenting the Crime Scene</h2><p>Time to get surgical. I needed to know exactly when the corruption happened.</p><p>The crash occurred when <code>main</code> tried to load the channel pointer from its stack. In Go, local variables live on the stack, and the channel variable <code>done</code> is no exception. Somewhere between &ldquo;main parks waiting for data&rdquo; and &ldquo;main wakes up,&rdquo; that pointer was getting trashed.</p><p>I added diagnostic prints to the channel receive code. The function <code>gopark</code> is what puts a goroutine to sleep and it saves the current state and switches to the scheduler:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Before parking
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>uint32_t</span> <span style=color:#f92672>*</span>chan_ptr_loc <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span><span style=color:#f92672>*</span>)(frame_pointer <span style=color:#f92672>+</span> <span style=color:#ae81ff>104</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;BEFORE: chan_ptr at %p = %08lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, chan_ptr_loc, <span style=color:#f92672>*</span>chan_ptr_loc);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gopark</span>(chanparkcommit, c, waitReasonChanReceive);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// After waking
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;AFTER: chan_ptr at %p = %08lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, chan_ptr_loc, <span style=color:#f92672>*</span>chan_ptr_loc);
</span></span></code></pre></div><p>The <code>frame_pointer + 104</code> calculation came from disassembling <code>main.main</code> and seeing where the compiler stored the <code>done</code> variable. This is tedious work: you look at the assembly, count the stack offsets, and figure out where each variable lives.</p><p>The output was damning:</p><pre tabindex=0><code>BEFORE: chan_ptr at 0x8c488728 = 8c084a50
AFTER:  chan_ptr at 0x8c488728 = 8c080106
</code></pre><p>The pointer was fine when main went to sleep. It was corrupted when main woke up. Something happened <em>while main was parked</em> and the only things running during that time were the sender goroutines.</p><p>This was a crucial realization. The corruption wasn&rsquo;t happening in main&rsquo;s code. It was happening in <em>someone else&rsquo;s</em> code, stomping on main&rsquo;s stack from the outside.</p><hr><h2 id=following-the-money>Following the Money</h2><p>In channel operations, when a sender finds a waiting receiver, it copies data directly to the receiver&rsquo;s stack. This is an optimization whereinstead of putting the data in the channel buffer and having the receiver copy it out, the sender writes straight to where the receiver wants the data.</p><p>The receiver provides a pointer (<code>sg->elem</code>) saying &ldquo;put the data here.&rdquo; The sender does <code>memcpy(sg->elem, &amp;value, size)</code>.</p><p>I added more instrumentation to the send path:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;sg-&gt;elem = %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, sg<span style=color:#f92672>-&gt;</span>elem);
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;channel elemsize = %u</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, c<span style=color:#f92672>-&gt;</span>elemsize);
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;memcpy %u bytes to %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, c<span style=color:#f92672>-&gt;</span>elemsize, sg<span style=color:#f92672>-&gt;</span>elem);
</span></span></code></pre></div><p>And there it was:</p><pre tabindex=0><code>Main&#39;s chan_ptr at 0x8c488768
sg-&gt;elem = 0x8c488766
memcpy 4 bytes to 0x8c488766
</code></pre><p>Do you see it?</p><p>The receiver&rsquo;s element pointer was at <code>0x8c488766</code>. The channel pointer was at <code>0x8c488768</code>. That&rsquo;s a difference of <em>two bytes</em>.</p><p>The memcpy was writing <em>four</em> bytes.</p><pre tabindex=0><code>0x8c488766  ← byte 0 of the bool
0x8c488767  ← byte 1 (overflow!)
0x8c488768  ← byte 2 (this is where the channel pointer starts!)
0x8c488769  ← byte 3 (still the channel pointer!)
</code></pre><p>The send operation was overflowing into the channel pointer. The 4-byte write was stomping on adjacent memory.</p><p>Mystery solved. Well&mldr; sort of. But why four bytes? The channel held <code>bool</code> values. A bool is one byte.</p><hr><h2 id=the-smoking-gun>The Smoking Gun</h2><p>I traced back to channel creation. When you call <code>make(chan bool, 2)</code>, the runtime calls an internal function <code>makechan</code> that allocates the channel structure. One of its jobs is to determine the element size:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>hchan <span style=color:#f92672>*</span><span style=color:#a6e22e>makechan</span>(<span style=color:#66d9ef>struct</span> __go_type_descriptor <span style=color:#f92672>*</span>elemtype, <span style=color:#66d9ef>int64_t</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> elemsize <span style=color:#f92672>=</span> elemtype<span style=color:#f92672>-&gt;</span>__size;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;elemsize = %zu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, elemsize);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Output:</p><pre tabindex=0><code>elemsize = 4
</code></pre><p>Four bytes. But bool is one byte. What was going on?</p><p>Here&rsquo;s where I need to explain something about Go&rsquo;s type system at the runtime level. Every type in Go has a <strong>type descriptor</strong>, a data structure that describes the type&rsquo;s size, its alignment, how to compare values of that type, how the garbage collector should scan it, and more. The compiler generates these descriptors and embeds them in the binary.</p><p>When you compile a Go program, you can see these type descriptors in the symbol table. The <code>nm</code> tool lists all symbols in a binary:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sh-elf-nm test_simple_exit.elf | grep <span style=color:#e6db74>&#34;type\.\.&#34;</span>
</span></span></code></pre></div><pre tabindex=0><code>8c052198 V _type..bool
8c0521bc V _type..chan_bbool
8c0521e4 V _type..func()
</code></pre><p>Each <code>_type..XXX</code> symbol is a type descriptor. The address <code>0x8c0521bc</code> is the descriptor for <code>chan bool</code>.</p><p>I had printed that the type descriptor passed to <code>makechan</code> was at address <code>0x8c0521bc</code>. Looking it up:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sh-elf-nm test_simple_exit.elf | grep 8c0521bc
</span></span></code></pre></div><pre tabindex=0><code>8c0521bc V _type..chan_bbool
</code></pre><p>That&rsquo;s <code>chan bool</code>, in which the <em>channel</em> type, not the <em>element</em> type!</p><hr><h2 id=understanding-the-root-cause>Understanding the Root Cause</h2><p>Here&rsquo;s what I had missed. The Go compiler doesn&rsquo;t pass the element type to <code>makechan</code>. It passes the <em>channel</em> type. This makes sense if you think about it. Remember: the runtime might need to know things about the channel itself (like its direction: send-only, receive-only, or bidirectional).</p><p>But the channel type descriptor contains a pointer to the element type. The structure looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// A plain type descriptor (for simple types like bool, int, etc.)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> __go_type_descriptor {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uintptr_t</span> __size;        <span style=color:#75715e>// Size of values of this type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uintptr_t</span> __ptrdata;     <span style=color:#75715e>// Size of memory prefix holding pointers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint32_t</span> __hash;         <span style=color:#75715e>// Hash of the type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// ... more fields ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// A channel type descriptor (extends the base descriptor)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> __go_chan_type {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> __go_type_descriptor __common;          <span style=color:#75715e>// Base type info (36 bytes)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> __go_type_descriptor <span style=color:#f92672>*</span>__element_type;   <span style=color:#75715e>// Pointer to element&#39;s type!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uintptr_t</span> __dir;                               <span style=color:#75715e>// Channel direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>When you have a <code>chan bool</code>, the type descriptor is a <code>__go_chan_type</code>. Its <code>__common.__size</code> field is the size of the channel type descriptor itself (which happens to be a small number due to struct. In my case, 4 bytes). The <em>element</em> size is in <code>__element_type->__size</code>.</p><p>My original code was doing this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// WRONG: This reads the channel type&#39;s size, not the element&#39;s size!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>size_t</span> elemsize <span style=color:#f92672>=</span> chantype<span style=color:#f92672>-&gt;</span>__size;  <span style=color:#75715e>// Returns 4 (size of chan type descriptor)
</span></span></span></code></pre></div><p>It should have been doing this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// CORRECT: Cast to chan_type, then get the element type&#39;s size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> __go_chan_type <span style=color:#f92672>*</span>ct <span style=color:#f92672>=</span> (<span style=color:#66d9ef>struct</span> __go_chan_type <span style=color:#f92672>*</span>)chantype;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> __go_type_descriptor <span style=color:#f92672>*</span>elemtype <span style=color:#f92672>=</span> ct<span style=color:#f92672>-&gt;</span>__element_type;
</span></span><span style=display:flex><span><span style=color:#66d9ef>size_t</span> elemsize <span style=color:#f92672>=</span> elemtype<span style=color:#f92672>-&gt;</span>__size;  <span style=color:#75715e>// Returns 1 (size of bool)
</span></span></span></code></pre></div><p>The fix was three lines, but understanding <em>why</em> those three lines were needed took days of investigation.</p><hr><h2 id=the-corruption-pattern-explained>The Corruption Pattern Explained</h2><p>With the root cause understood, the corrupted value <code>0x8c080106</code> suddenly made sense.</p><p>The original channel pointer was <code>0x8c084a50</code>. On a little-endian system (which the SH-4 is), this is stored in memory as bytes <code>50 4a 08 8c</code>.</p><p>The bool value <code>true</code> is stored as <code>0x01</code>. But we were writing 4 bytes, not 1. The extra 3 bytes came from whatever garbage happened to be adjacent to the source value.</p><p>The write started 2 bytes before the channel pointer. After the 4-byte memcpy:</p><pre tabindex=0><code>Memory before:  ?? ?? 50 4a 08 8c
                      ^^ channel pointer starts here
                
Memory after:   ?? ?? 06 01 08 8c
                      ^^ ^^ overwritten by the 4-byte write
</code></pre><p>Reading those 4 bytes as a little-endian 32-bit value: <code>0x8c080106</code>. Exactly what the crash reported.</p><p>The <code>01</code> in the corrupted value was literally the boolean <code>true</code> being written. The corruption left a fingerprint. I just didn&rsquo;t recognize it until I understood what was happening.</p><hr><h2 id=could-i-have-found-this-faster>Could I Have Found This Faster?</h2><p>Absolutely. Looking back, there were several points where I could have short-circuited the investigation:</p><p><strong>1. I should have checked the element size immediately.</strong></p><p>When the crash first happened, I could have added a simple print to <code>makechan</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Creating channel: elemsize=%zu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, elemsize);
</span></span></code></pre></div><p>Seeing &ldquo;elemsize=4&rdquo; for a <code>chan bool</code> would have been an immediate red flag. Instead, I spent days chasing register corruption theories.</p><p><strong>2. I should have analyzed the corrupted value sooner.</strong></p><p>The value <code>0x8c080106</code> wasn&rsquo;t random. It had structure:</p><ul><li>The upper bytes <code>08 8c</code> matched the heap region prefix</li><li>The <code>01</code> byte screamed &ldquo;boolean true&rdquo;</li></ul><p>If I had stared at that value and asked &ldquo;where could <code>01</code> come from?&rdquo;, I might have connected it to the channel send much earlier.</p><p><strong>3. I should have added memory guards.</strong></p><p>A simple technique: when allocating the receive buffer, pad it with known sentinel values and check if they get overwritten:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Allocate extra space with sentinels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>16</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0xDE</span>, <span style=color:#ae81ff>0xAD</span>, <span style=color:#ae81ff>0xBE</span>, <span style=color:#ae81ff>0xEF</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0xDE</span>, <span style=color:#ae81ff>0xAD</span>, <span style=color:#ae81ff>0xBE</span>, <span style=color:#ae81ff>0xEF</span>, ...};
</span></span><span style=display:flex><span><span style=color:#75715e>// The actual receive goes into buffer[4]
</span></span></span><span style=display:flex><span><span style=color:#75715e>// After receive, check if buffer[0..3] or buffer[5..] changed
</span></span></span></code></pre></div><p>This would have immediately shown that the write was overflowing.</p><p><strong>4. I got distracted by the struct layout issue.</strong></p><p>The G struct layout mismatch was a real bug, and fixing it was the right thing to do. But I spent too long on it, convinced it must be the cause of this specific crash. When the crash persisted after the fix, I should have immediately pivoted to other theories instead of double-checking the struct layout for the third time.</p><hr><h2 id=the-lesson>The Lesson</h2><p>This bug took about four days to find. That might sound like a lot for what turned out to be a simple type confusion. But here&rsquo;s the thing: debugging is rarely a straight line.</p><p>I went down the register corruption path. Dead end, but I learned my context switching was correct.</p><p>I went down the struct layout path. Found and fixed a real bug, but not <em>this</em> bug.</p><p>I went down the stack corruption path. Finally found the culprit.</p><p>Each &ldquo;wrong&rdquo; path wasn&rsquo;t wasted time. It was eliminating possibilities and building understanding. The struct layout investigation taught me exactly how gofrontend lays out its data structures. The register corruption investigation confirmed my assembly was sound. By the time I found the real bug, I understood the system much more deeply than when I started.</p><p>That&rsquo;s how you build expertise. Not by reading documentation (though that helps), but by breaking things and figuring out why they broke.</p><hr><h2 id=epilogue>Epilogue</h2><p>The Dreamcast is a 27-year-old console. Getting Go to run on it means understanding both the high-level abstractions and the low-level reality of how compilers generate code. The Go language presents a clean model: goroutines, channels, garbage collection. But underneath, there&rsquo;s assembly code shuffling registers, type descriptors encoding metadata, and memory being copied byte by byte.</p><p>Sometimes a bug that looks like black magic: registers corrupted, pointers changing spontaneously, has a perfectly mundane explanation. A type cast that should have been there. A field that should have been dereferenced. Three lines of code.</p><p>You just have to find it.</p><hr><p><em>The code for libgodc (will soon be available) at <a href=https://github.com/drpaneas/libgodc>github.com/pgeorgia/libgodc</a>. If you&rsquo;re interested in Go internals, I recommend reading the <a href=https://github.com/golang/go/tree/master/src/runtime>runtime source code</a>. It&rsquo;s surprisingly approachable, and there&rsquo;s no better way to understand what your programs are actually doing.</em></p></div><div class=post-footer></div></article></main></body></html>